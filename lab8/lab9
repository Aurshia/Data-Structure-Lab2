#include <iostream>
using namespace std;

class Queue{
  int *arr;
  int capacity;
  int frontidx;
  int rearidx;
  int currentsize;

  void resize(){
    int newCapacity = capacity * 2;
    int *newArr  = new int[newCapacity];
    for(int i = 0 ; i < currentsize ; i++){
        newArr[i]  = arr[(frontidx + i) % capacity];
    }
    delete[] arr;
    arr = newArr;
    capacity = newCapacity;
    frontidx = 0;
    rearidx = currentsize;
  }

public: 
  Queue(int initialCapacity = 4){
    capacity = initialCapacity;
    arr = new int[capacity];
    currentsize = 0;
    frontidx = 0;
    rearidx = 0;
  }

  ~Queue(){
    delete[] arr;  
  }

  bool isEmpty() const{
    return currentsize == 0;
  }

  int size() const{
    return currentsize;
  }

  void enqueue(int value){
    if(currentsize == capacity){
       resize();
    }
    arr[rearidx] = value;
    rearidx = (rearidx +1)%capacity;
    currentsize++;
  }

  void dequeue(){
    if(isEmpty()){
        cout<<"Queue underflow";
        return;
    }
    frontidx =(frontidx + 1)%capacity;
    currentsize--;
  }

  int front() const{
    if(isEmpty()){
        cout<<"Queue is empty"<<endl;
        return -1;
    }  
    return arr[frontidx];
  }

  void print() const {
    cout<<"Queue elements: ";
    for(int i = 0 ; i< currentsize ; i++){
        int index = (frontidx + i)% capacity;
        cout<<"elements: "<<arr[index]<<" ";
    }
    cout<<"\n";
  }
    
};

int main()
{
    Queue q;
    cout<<"Enqueue 10 , 20 ,30 , 40\n";
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.print();
    cout<<"Front element: "<<q.front()<<"\n";
    cout<<"Dequeue two elements\n";
    q.dequeue();
    q.dequeue();
    q.print();
    cout<<"Front element now: "<<q.front()<<"\n";
    cout<<"Enqueue 50 , 60 , 70 (this will cause resize internally\n";
    q.enqueue(50);
    q.enqueue(60);
    q.enqueue(70);
    q.print();
    cout<<" Dequeuing all elemnts:\n";
    while(!q.isEmpty()){
        cout<<"Front: "<<q.front()<<" -> dequeued\n";
        q.dequeue();
    }
    q.dequeue();
    return 0;
}
